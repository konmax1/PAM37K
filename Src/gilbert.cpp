#include "gilbert.h"

// импульсная характеристика преобразования
const float GILBERT_COEFF [GILBERT_POR + 1]={4.54486433486115e-05, -0.0319136045611685, -3.31277815639291e-05,
-0.0260478358874455, -1.59427170179442e-06, -0.0373284021357407, 3.46942587567515e-06, -0.0531107459937533,
-1.03378562696214e-06, -0.0766995375013512, -5.96683448033596e-06, -0.116853826766850, 1.66624629076986e-05,
-0.205805810057242, -1.89302802971010e-05, -0.634472629392063, 0, 0.634472629392063, 1.89302802971010e-05,
0.205805810057242, -1.66624629076986e-05, 0.116853826766850, 5.96683448033596e-06, 0.0766995375013512,
1.03378562696214e-06, 0.0531107459937533, -3.46942587567515e-06, 0.0373284021357407, 1.59427170179442e-06,
0.0260478358874455, 3.31277815639291e-05, 0.0319136045611685, -4.54486433486115e-05};

float GilbertBufer[GILBERT_POR];       // линия задержки для преобразования (мнимая часть)

float GilbertTransform(float &sample) {  
   float res = sample * GILBERT_COEFF[0];
   volatile int i;
   for(i=0; i<GILBERT_POR; i++) {       // КИХ-фильтрация
     res += GilbertBufer[i]*GILBERT_COEFF[i+1];
   }
   for(i=GILBERT_POR-1;i>0;i--)         // передвижка линии задержки
     GilbertBufer[i] = GilbertBufer[i-1];
   GilbertBufer[0]=sample;
   sample = GilbertBufer[GILBERT_POR2];  // переписываем реальную часть (задержанную)
   return res;                         
};
